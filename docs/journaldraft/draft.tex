\documentclass{article}
\usepackage{cuted}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{algorithm,algpseudocode}
\algnewcommand{\LeftComment}[1]{\(\triangleright\) #1}
\algrenewcommand\algorithmicindent{.5em}
\usepackage{graphicx}
\usepackage{color}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{geometry}
\newgeometry{tmargin=2cm,lmargin=2cm,rmargin=2cm,bmargin=2cm}
\usepackage[style=ieee,backend=biber,texencoding=utf8,bibencoding=utf8,dashed=false,isbn=false,url=false,doi=false,eprint=false,]{biblatex}
\renewbibmacro{in:}{}
\DeclareFieldFormat{journaltitle}{#1}
\DeclareFieldFormat{booktitle}{#1}
%\renewrobustcmd*{\bibinitdelim}{}
\addbibresource{../res/MyCollection.bib}
\graphicspath{{../res/figure/}{./plot/}}
\makeatletter
\def\input@path{{../res/figure/}{./table/}}
\makeatother
\addbibresource{../res/MyCollection.bib}

\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\linespread{1.5}

\title{An Algorithm to Update Betweenness Centrality \\ Accurately on Edge Delete}
\author{Bubo bubo}

\begin{document}
\maketitle

\begin{abstract}
  Betweenness centrality is one of various centralities that implements importance as appearance on shortest paths.
  Many algorithms to calculate BC have been developed after Brandes developed an algorithm that accumulates pair-dependencies.
  While many real networks are temporal, algorithms to maintain and update BC have been also developed.
  Since Brandes’ algorithm finds single source shortest paths (SSSP) at first, many algorithms, that are combinations of algorithms to update SSSP and Brandes’ algorithm, have been developed.
  To the best of our effort, no decremental algorithm was proposed based on Ramalingam and Reps' shortest path update algorithm.
  In this paper, we develop an algorithm to update BC when an edge is deleted from a graph.
  We provide the proof of the correctness of proposed algorithm.
  We analyze its efficiency by both theoretical and experimental aspects.
  As the result, proposed algorithm outperforms existing static algorithm.
\end{abstract}

\section{Introduction}
Betweenness centrality\cite{Freeman1977} (BC) is one of various centralities, which measure importance of network components.
Especially, BC implements importance as appearance on shortest paths.
Many algorithms to calculate BC have been developed after Brandes\cite{Brandes2001} developed an algorithm that accumulates pair-dependencies.

While networks in real life have node and link alternations\cite{Holme2012}, algorithms to maintain and update BC have been also developed.
Since Brandes’ algorithm finds single source shortest paths (SSSP) at first, many algorithms, that are combinations of algorithms to update SSSP and Brandes’ algorithm, have been developed.
Although an incremental algorithm based on Ramalingam and Reps' (RR) algorithm\cite{Ramalingam1996} was proposed, no decremental algorithm was proposed to the best of our effort.

In this research, we propose a decremental algorithm to update BC based on RR algorithm.
We also examine its efficiency by both theoretical complexity analysis and numerical experiments.

The organization of this paper is following.
Section 2 shows related work, mainly these are algorithms to update BC and SSSP simultaneously.
In section 3, we explain notations, which will be used on the remaining of this paper.
Section 4 shows our proposed algorithm with theorem of criteria for updating dependency.
Section 5 shows the time complexity of proposed algorithm and section 6 shows efficiency of proposed algorithm by numerical experiment.
Although worst-case complexity is same as one of Brandes' algorithm, execution time was improved in many cases.

\section{Related Work}
Betweenness centrality (BC) was proposed in need of measurement of node significance\cite{Freeman1977}.
Following the definition as it is, the time complexity to calculate BC of all nodes is $\mathcal{O}(\lvert V\rvert^3)$ due to the explicit summation of pair-dependency.
Brandes' algorithm\cite{Brandes2001} performs this summation implicitly and reduces time complexity to $\mathcal{O}(\lvert V\rvert\lvert E\rvert+\lvert V\rvert^2\log\lvert V\rvert)$ in weighted networks.
Almost all algorithms developed after Brandes' algorithm, uses this implicit accumulation technique.
Some algorithms parallelize the accumulation\cite{Bader2006,Tan2009,Edmonds2010} or use GPGPU\cite{Shi2011,Sariyuce2013,Bernaschi2016}.
Some algorithms are to approximate BC by sampling and extrapolation\cite{Brandes2007,Bader2007,Geisberger2008,Chehreghani2014,Riondato2014,Riondato2016,Borassi2019},
by setting upper bound of distance\cite{Pfeffer2012}, and by using hypergraph sketch\cite{Yoshida2014}.

As many real networks have node/link alternations\cite{Holme2012}, algorithms to update BC for dynamic networks also have been developed.
To the best of our effort, the first algorithm is QUBE\cite{Lee2012} that caches maximum union cycles(MUCs).

Limiting to algorithms which update BC exactly, many algorithms cache single source shortest paths (SSSPs) or their subordinating metrics to update BC efficiently
\cite{Green2012,Kas2013,Nasre2014a,Nasre2014b,Pontecorvi2015,Bergamini2017}.
Green, McColl, and Bader\cite{Green2012} developed an algorithm for incremental update on unweighted networks.
Kas, Wachs, Carley and Carley\cite{Kas2013} developed an algorithm for incremental update based on Ramalingam and Reps' (RR) algorithm\cite{Ramalingam1996}.
Nasre, Pontecorvi, Ramachandran\cite{Nasre2014a} developed an algorithm for incremental update based on Karger, Koller, and Phillips' idea\cite{Karger1993}.
Nasre, Pontecorvi, and Ramachandran\cite{Nasre2014b} developed an algorithm for decremental update based on Demetrescu and Italiano's (DI) algorithm\cite{Demetrescu2003}.
Pontecorvi and Ramachandran\cite{Pontecorvi2014} developed an algorithm for fully-dynamic networks based on DI algorithm.
Bergamini, Meyerhenke, Ortmann, and Slobbe\cite{Bergamini2017} developed an algorithm for incremental update based on RR algorithm.

Other algorithms: caches MUCs\cite{Singh2015}, update node BC and edge BC simultaneously\cite{Kourtellis2015}, are approximation algorithms\cite{Hayashi2015,Bergamini2015a,Bergamini2015b,Chernoskutov2015}, and is parallel algorithm\cite{Jamour2017}.

\subsection*{Our Contribution}
However, to best of our knowledge, no algorithm for decremental update based on Ramalingam and Reps' SSSP update algorithm.
The aim of this research is filling in the missing piece of the group of algorithms to update BC accurately on dynamic networks.
In this research, we develop an algorithm to update BC for decremental update based on Ramalingam and Reps' algorithm.
We also examine its efficiency by both theoretical and experimental approach.

\section{Notation}
A graph $G$ is a pair $(V,E)$ which $V$ and $E$ are vertex and edge set respectively.
$G=(V,E)$ is an undirected graph if elements of $E$ are unordered pairs, denoted by $\{v,w\}\in E$.
Similarly, $G=(V,E)$ is a directed graph if elements of $E$ are ordered pairs, denoted by $(v,w)\in E$.
A graph $G=(V,E)$ is said to be weighted if weights (or length) $l_{vw}$ are defined for each $\{v,w\}\in E$ for an undirected graph and $(v,w)\in E$ for a directed graph.
For an undirected graph $G$, neighbors of $v\in G$ is denoted by $\mathcal{N}_G(v)$.
More generally, $\mathcal{N}_G^i(v)=\left(\bigcup_{w\in\mathcal{N}_G^{i-1}(v)}\mathcal{N}_G(w)\right)\setminus\left(\bigcup_{j=1}^{i-1}\mathcal{N}_G^j(v)\right)\setminus\{v\}$ and $\mathcal{N}_G^1(v)=\mathcal{N}_G(v)$.
For a directed graph $G$, $\mathcal{S}(v)$ and $\mathcal{P}(v)$ be successors and predecessors of $v\in G$ respectively.
We introduce $\mathcal{S}_G^i(v)$ and $\mathcal{P}_G^i(v)$ similar to $\mathcal{N}_G^i(v)$, 

A single source shortest path (SSSP) digraph of a source $s\in V$ on $G=(V,E)$ is denoted by $G_s=(V_s,E_s)$.
Similarly, $G_{st}=(V_{st},E_{st})$ denotes SSSP digraph of source $s\in V$ and target $t\in V$ on $G=(V,E)$.
The distance and the number of shortest paths between two vertices $s,t\in V$ are denoted by $d_{st}$ and $\sigma_{st}$ respectively.
Also, $\sigma_{st}(v)$ denotes the number of shortest paths from $s$ to $t$ which pass through $v$.
Let $d_{ss}=0$ and $\sigma_{ss}=1$ for convenience.
Let $G_{s}(v)=\left(V_s(v),E_s(v)\right)$ be a directed subgraph of $G_s$, which  $V_s(v)$ and $E_s(v)$ are $V_s(v)=\{w|w\in V_s,\,d_{sw}=d_{sv}+d_{vw}\}$ and $E_s(v)=\{(w,x)|(w,x)\in E_s,\,d_{sx}=d_{sv}+d_{vw}+l_{wx}\}$ respectively.
A semantic explanation of $G_s(v)$ would be a graph which is constituted of components behind $v$ on $G_s$.

The betweenness centrality of vertex $v$ is defined as
\begin{equation}
  B_{v}=\sum_{s\neq v}\sum_{t\neq s,v}\frac{\sigma_{st}(v)}{\sigma_{st}}.
  \label{eq:bc-base}
\end{equation}
The pair-dependency of vertex pair $s,t$ on an intermediary vertex $v$ is denoted by $\delta_{st}(v)$ and defined as the ratio of the number f shortest paths from $s$ to $t$ to those pass through $v$
(i.e. $\delta_{st}(v)=\sigma_{st}(v)/\sigma_{st}$.)
The dependency of vertex $s$ on vertex $v$ is defined as sum of $\delta_{st}(v)$ for all $t\in V\setminus\{s,v\}$, and denoted by $\delta_{s\bullet}(v)$.
With $\delta_{s\bullet}(v)$, equation \eqref{eq:bc-base} can be rewritten as $B_{v}=\sum_{s\neq v}\delta_{s\bullet}(v)$.

\section{Proposed Algorithm}
This section shows our algorithm our algorithm to update BC when an edge $\{v,w\}\in E$ is deleted.
The graph components and metrics are put $'$ symbol in order to indicate that these are post-delete components/metrics (e.g. $d'_{st}$ is distance after delete.)
An algorithm to update BC when the weight of an edge increases would be easily deduced from this algorithm.

The algorithm updates dependency $\delta_{t\bullet}(v)$ for all $t,v\in V$ by running following procedures for all $t\in V$:
find affected vertices by delete, update $d_{st}$ and $\sigma_{st}$ for all $s\in V$, and update $\delta_{t\bullet}(v)$ for all $v\in V$.

\subsection*{Finding affected vertices}
Following lemma shows the condition whether $d_{xt}$ or $\sigma_{xt}$ of a vertex pair $(x,t)$ has to be updated or not.

\begin{lemma}
  \label{lm:affected-vertices}
  For $x,t\in V$, $d_{xt}\neq d'_{xt}\lor\sigma_{xt}\neq\sigma'_{xt}$ if and only if $d_{xv}+l_{vw}+d_{wt}=d_{vt}$.
\end{lemma}

A set of affected vertices, which consists of vertices with satisfying Lemma \ref{lm:affected-vertices}, is denoted by $\mathcal{A}$.
Branch pruned depth first search is applied to find $\mathcal{A}$ efficiently.

\subsection*{Updating $d_{st}$ and $\sigma_{st}$}
an affected vertices $x\in \mathcal{A}$, which satisfies
\begin{equation}
  \mathcal{N}_{G'}(x)\cap\mathcal{A}\neq\varnothing,
  \label{eq:update-augdist-1}
\end{equation}
can be updated immediately as they have unaffected neighbors.
For these vertices, find $d'_{xt}$ and $\sigma'_{xt}$ by
\begin{equation*}
  \begin{aligned}
    d'_{xt}&=\min_{y\in\mathcal{N}_{G'}(x),y\notin\mathcal{A}}\{l_{xy}+d_{yt}\}, \\
    \sigma'_{xt}&=\sum_{y\in\mathcal{N}_{G'}(x),y\notin\mathcal{A},d'_{xt}=l_{xy}+d_{yt}}\sigma_{yt}.
  \end{aligned}
\end{equation*}

For remaining vertices, update these distances and the number of shortest paths by branch pruned Dijkstra's algorithm, described as follows:
\begin{enumerate}
\item push $(y,l_{yx}+d'_{xt})$ to the priority queue for all $x\in\mathcal{A}$ that satisfies \eqref{eq:update-augdist-1} and $y\in\mathcal{N}_{G'}(x)\cap\mathcal{A}$.
\item until the priority queue has any element,
  \begin{enumerate}
  \item pop an element from priority queue and let it be $(x,\hat{d}_{xt})$,
  \item update $d_{xt}$ and $\sigma_{xt}$ by
    \begin{equation*}
      \begin{aligned}
        d'_{xt}&=\hat{d}_{xt}, \\
        \sigma'_{xt}&=\sum_{y\in\mathcal{N}_{G'}(x),d'_{xt}=l_{xy}+d'_{yt}}\sigma'_{yt}.
      \end{aligned}
    \end{equation*}
  \item For all $y\in\mathcal{N}_{G'}(x)$ that satisfy $d_{yt}\geq l_{yx}+d'_{xt}$, push $(y,l_{yx}+d'_{xt})$ to the priority queue.
  \end{enumerate}
\end{enumerate}

\subsection*{Updating $\delta_{t\bullet}(v)$}
Following lemma shows the condition whether $\delta_{xt}$ of a vertex pair $(x,t)$ needs to be updated or not.
\begin{lemma}
  \label{lm:update-delta-1}
  For $s,x\in V$, if $E_{G_s}(x)=E'_{G_s}(x)$ and $\sigma_{sy}=\sigma'_{sy}$ for all $y\in V_{G_s(x)}$ then, $\delta_{s\bullet}(x)=\delta'_{s\bullet}(x)$.
\end{lemma}

The converse of Lemma \ref{lm:update-delta-1} has a counterexample.
\begin{example}
  On Figure \ref{fig:update-delta},
  $\delta_s(v_1)=\delta'_s(v_1)$ but $\delta_s(w_1)\neq\delta'_s(w_1)$.
  Also, $\delta_s(v_2)=\delta'_s(v_2)$ but $\sigma_{sv_2}\neq\sigma'_{sv_2}$.
\end{example}

\begin{figure*}
  \centering
  \def\svgwidth{.45\linewidth}
  \input{pd-invariability-counterexample.pdf_tex}
  \caption{Counterexample of converse of Lemma \ref{lm:update-delta-1}.}
  \label{fig:update-delta}
\end{figure*}

\begin{lemma}
  \label{lm:update-delta-2}
  For $s,v\in V$, following \ref{item:update-delta-2-1}, \ref{item:update-delta-2-2}, and \ref{item:update-delta-2-3} are equivalent.
  \begin{enumerate}[label={\normalfont (\alph*)}]
  \item $E_{G_s}(v)=E_{G'_s}(v)$ and $\sigma_{sw}=\sigma'_{sw}$ for all $w\in V_{G_s}(v)$.
    \label{item:update-delta-2-1}
  \item $V_{G_s}(v)=V_{G'_s}(v)$ and $\sigma_{sw}=\sigma'_{sw}\land\mathcal{S}_{G_s}(w)=\mathcal{S}_{G'_s}(w)$ for all $w\in V_{G_s}(v)$.
    \label{item:update-delta-2-2}
  \item for all $w\in V_s(v)$ and $x\in\mathcal{N}_G(w)$,
    $x\in\mathcal{S}_{G_s}(w)\land x\in\mathcal{S}_{G'_s}$
    $\lor x\notin\mathcal{S}_{G_s}(w)\land x\notin\mathcal{S}_{G'_s}$.
    \label{item:update-delta-2-3}
  \end{enumerate}
\end{lemma}

Our update strategy is following: find vertex pairs $(v,t)\in V\times V$ that does not satisfy condition \ref{item:update-delta-2-3} of Lemma \ref{lm:update-delta-2} and update dependency $\delta_{t\bullet}(v)$ of these vertex pairs only.
Although unnecessary update may occur, update miss cannot occur.
At the end of this section, we show the detailed procedure on Algorithm\ref{algo:decremental-algorithm}.

\section{Complexity Analysis}
In this section, we examine the efficiency of our proposed algorithm from time complexity analysis.
Firstly, we introduce some concepts on affected amount of graph components for later discussion.

\begin{definition}
  
  Finally, set of vertices which is updated its BC is denoted as $V_\delta$.
  And an edge set consists of edges, incident to vertex in $V_\delta$ is denoted as $E_\delta$.
  \begin{equation*}
    \begin{aligned}
      V_\delta&=\{x|\exists t,\,x\in V_\delta(t)\} \\
      E_\delta&=\{\{x,y\}|x\in V_\delta\lor y\in V_\delta\}
    \end{aligned}
  \end{equation*}
\end{definition}

Generally speaking, discussing the relationship between the number of vertices that their BC changed and $\lvert V_\delta\rvert$ is difficult.

\begin{example}
  On deleting $\{V,W\}$ on the graph in Figure \ref{fig:bc-many-phony}, the number of updated vertices $\lvert V_\delta\rvert$ holds $\lvert V_\delta\rvert\sim \lvert V\rvert$,
  while the number of changing vertices is $4$ ($T,U,V,W$.)
\end{example}
\begin{figure*}[tb]
  \centering
  \def\svgwidth{.8\linewidth}
  \input{bc-many-phony.pdf_tex}
  \caption{Example of network with many unnecessary updates}
  \label{fig:bc-many-phony}
\end{figure*}

\begin{theorem}
  \label{tm:time-complexity}
  The time complexity of \textproc{Decremental} on Algorithm \ref{algo:decremental-algorithm} is
  $\mathcal{O}(\lvert V_\delta\rvert\lvert E_\delta\rvert+\lvert V_\delta\rvert^2\log \lvert V_\delta\rvert)$.
\end{theorem}

\section{Experiment}
In this section, we examine the efficiency of our proposed algorithm from numerical experiments.
All experiments were conducted on following environment: Intel (R) Xeon (R) CPU E-2620 v4 and 64GB RAM. All programs were compiled by gcc 7.2.0 with -O3 flag.
Source code is published on \verb|github.com/y-satotani/dynamic-betweenness.|

\subsection*{On synthesized networks}
This experiment compare our proposed algorithm with Brandes' algorithm on synthesized networks such as Erd{\"{o}}s-R{\'{e}}nyi network\cite{Erdos1959} and Barab{\'{a}}si-Albert network\cite{Barabasi1999}.
We also validate the result of complexity analysis.

Figure \ref{fig:exp-artificial-order} shows the execution time of both algorithms to network order.
The average degree of both network topologies is $4$.
From the figure, we can confirm that proposed algorithm outperforms Brandes' algorithm, since proposed algorithm seems to update a smaller number of dependencies.

\begin{figure}
  \centering
  \includegraphics{exp-artificial-order.pdf}
  \caption{Comparison of excution time on synthesized networks}
  \label{fig:exp-artificial-order}
\end{figure}

To validate this state, we count the number of vertex pairs which are updated its dependency.
Figure \ref{fig:exp-artificial-update} shows the relationship between the number of vertex pairs $(v,t)$, which updated its $\delta_{t\bullet}(v)$, and execution time.
The order and the average degree of networks are $1000$ and $4$ respectively.
From the figure, when the algorithm updates more dependencies, more execution time takes.
The figure also indicates when the network is dense (i.e. has many edges), more execution time takes.

\begin{figure}
  \centering
  \includegraphics{exp-artificial-update.pdf}
  \caption{The relationship between the number of updated vertex pairs and execution time}
  \label{fig:exp-artificial-update}
\end{figure}

Figure \ref{fig:exp-artificial-phony} shows the relationship between the number of vertices with its BC was actually changed and updated.
For Barab{\'{a}}si-Albert models, $3$ times more than changed vertices were updated vertices in worst case.

\begin{figure}
  \centering
  \includegraphics{exp-artificial-phony.pdf}
  \caption{Relationship between changed BC and updated BC}
  \label{fig:exp-artificial-phony}
\end{figure}

\subsection*{On real networks}
In this experiment, we compare proposed algorithm to Brandes' algorithm on real networks.
Real networks are from SNAP\cite{Leskovec2016}.
For proposed method, we calculated $d_{st}$, $\sigma_{st}$, and $\delta_{t\bullet}(v)$ for all vertex pairs $(s,t),(v,t)\in V\times V$.
Then, we deleted one edge and measured execution time of update.
Table \ref{tab:exp-real} shows performance comparison of Brandes' algorithm and proposed algorithm.
We calculated maximum and mean of execution time for $10$ runs.
From Table \ref{tab:exp-real}, proposed algorithm outperforms Brandes' algorithm even for real networks.

\include{exp-misc}

\section{Conclusion}
In this paper, we developed an algorithm to update BC when an edge is deleted from a graph.
We proofed the correctness of proposed algorithm.
We analyzed its efficiency by both theoretical and experimental aspects.
As the result, proposed algorithm outperformed existing static algorithm.
Our future work are followings.
One is to develop algorithm that update BC without preserving dependency, developed by Bergamini\cite{Bergamini2017}.
One is to develop dynamic algorithm for multiple edge update with this manner.

{
  \linespread{1.0}
  \printbibliography[title=References]
}

\appendix

{
  \linespread{1.0}
  \include{algorithm}
}

\include{proofs}

\end{document}
